<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>プログラマの為の数学勉強会</title>

    <!-- For reveal.js -->
    <link rel="stylesheet" href="lib/reveal/css/reveal.css">
    <link rel="stylesheet" href="lib/reveal/css/theme/night.css">
    <link rel="stylesheet" href="lib/reveal/lib/css/ir_black.css">

    <!-- For Graphics -->
    <link rel="stylesheet" href="css/graphics.css">

    <style>
      .reveal .chapter-title {
        margin-top: 3em;
      }

      .reveal {
        font-size: 32px;
        line-height: 1.4em;
      }

      .reveal .slides {
        text-align: left;
      }

      .reveal section img {
        border: none;
        background: 0;
        margin-left: 1em;
        margin-right: 1em;
        box-shadow: none;
      }

      .reveal strong {
        color: yellow;
      }

      .reveal sup {
        font-size: 40%;
      }

      .reveal table {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        border: 2px solid lightblue;
      }

      .reveal pre {
        font-size: 0.7em;
      }

      .reveal pre code {
        max-height: 600px;
      }

      .reveal .note {
        font-size: 50%;
      }

      .reveal .controls div.navigate-up,
      .reveal .controls div.navigate-down {
        display: none;
      }

      .reveal .block {
        border: solid 2px;
        position: relative;
        border-radius: 8px;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        padding: 1em 0.8em 1em 0.8em;
      }

      .reveal .block:after {
        content: "";
        display: block;
        clear: both;
        height: 1px;
        overflow: hidden;
      }

      .reveal .answer {
        color: #111111;
      }

      .reveal .block h4 {
        position: absolute;
        top: -0.5em;
        margin: 0 auto;
        background: #111111;
        font-weight: bold;
      }

    </style>

    <!-- Setup libraries for RequireJS-->
    <script src="lib/require.js"></script>

    <script>
      requirejs.config({
        baseUrl: "js",
        paths: {
          d3: "../lib/d3/d3.v3.min",
          numeric: "../lib/numeric-1.2.6",
          MathJax: "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"
        },
        shim: {
          d3: { exports: "d3" },
          numeric: { exports: "numeric" },
          MathJax: { exports: "MathJax" }
        }
      });
    </script>

    <!-- Initialize MathJax -->
    <script type="text/x-mathjax-config">
      require(["MathJax"], function (MathJax){
        MathJax.Hub.Register.StartupHook("AsciiMath Jax Config", function () {
          var AM = MathJax.InputJax.AsciiMath.AM;
          AM.symbols.push(
            {input:"mathbi",tag:"mstyle",atname:"mathvariant",atval:"bold-italic",
             output:"mathbi",tex:null,ttype:AM.TOKEN.UNARY}
          );
        });

        MathJax.Hub.Config({
          showProcessingMessages: false,
          skipStartupTypeset: false,
          tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ["\\[","\\]"] ]
          }
        });
      });
    </script>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section style="text-align: center">
        <h1> プログラマの為の<br>数学勉強会<br>第3回</h1>
        <span>
          (於)ワークスアプリケーションズ<br>
          中村晃一<br>
          2013年9月26日
        </span>
        </section>

        <section>
        <h2>謝辞</h2>
        <p>
        この会の企画・会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ様<br>
        にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h2> この資料について </h2>
        <p>
        <ul>
          <li> <a href="http://nineties.github.com/math-seminar">
            http://nineties.github.com/math-seminar
            </a>に置いてあります。 </li>
            <li> SVGに対応したブラウザで見て下さい。主要なブラウザで古いバージョンでなければ大丈夫だと思います。</li>
            <li> 内容の誤り、プログラムのバグは<a href="http://twitter.com/9_ties">@9_ties</a>かkoichi.nakamur AT gmail.comまでご連絡下さい。</li>
            <li> サンプルプログラムはPythonで記述しています。 </li>
        </ul>
        </p>
        </section>

        <section>
        <h2 class="chapter-title"> 微分法の応用 </h2>
        </section>

        <section>
        <h3> 準備 </h3>
        <p>
        最初に,本日の議論に必要となる<strong>連続性</strong>，<strong>微分可能性</strong>,<strong>極値</strong>,<strong>ロルの定理</strong>について説明します。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> 連続性 </h4>
          <p>
          \[ \lim_{x\rightarrow a}f(x) = f(a) \]
          が成立する時，\(f(x)\)は\(x=a\)で<strong>連続</strong>であるという。
          </p>
        </div>
        <div align="center"> <img width="800px" src="fig/continuity.png"> </div>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> 微分可能性 </h4>
          <p>
          \[ f'(a) = \lim_{h\rightarrow 0}\frac{f(a+h)-f(a)}{h} \]
          が収束する時，\(f(x)\)は\(x=a\)で<strong>微分可能</strong>であるという。
          </p>
          <p>
          同様に，\(n\)階微分係数\(f^{(n)}(a)\)が存在する時\(x=a\)で<strong>\(n\)回微分可能</strong>であるという。
          </p>
        </div>
        <p>
        直感的には,微分可能性は曲線が滑らかであるという事だと解釈できます。また証明は省略しますが,<strong>\(f(x)\)が\(x=a\)で微分可能ならばその点で連続である</strong>事を示す事が出来ます。
        </p>
        <div align="center"> <img width="700px" src="fig/differentiability.png"> </div>
        </section>

<!--
        <section>
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> 微分可能ならば連続 </h4>
          <p>
          \(f(x)\)が\(x = a\)で微分可能ならば,\(x = a\)で連続である。
          </p>
        </div>
        <p style="font-size:80%">【証明】<br>
        \[ \begin{aligned}
        \lim_{x\rightarrow a}f(x) &= \lim_{x\rightarrow a}\left\{\frac{f(x)-f(a)}{x-a}(x-a) + f(a)\right\} \\
              & = f'(a)\times 0 + f(a)\\
              & = f(a)
        \end{aligned} \]
        <span style="float:right">□</span>
        </p>
        </section>
-->

        <section>
        <h2> 極大値・極小値 </h2>
        <p>
        局所的に見れば最大・最小となる値を<strong>極値</strong>と言います。
        </p>
        <p>
        「最も良い～を求める」という形の問題の多くは何らかの最大値・最小値問題に帰着します。極値はその候補になるため重要です。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> 極値 </h4>
          <p>
          \(f(x\))を連続な関数，\(a\)を定数とする。適当な\(\varepsilon > 0\)が存在して
          \(f(a)\)が区間(\(a-\varepsilon, a+\varepsilon\))の最大値となるならば，
          \(f(a)\)を<strong>極大値</strong>，最小値となるならば<strong>極小値</strong>といい，これらを併せて<strong>極値</strong>という。
          <div align="center"> <img width="500px" src="fig/local-maximum.png"> </div>
          </p>
        </div>
        <p style="font-size:80%">
        つまり，\(f(a)\)が極大値である事は絶対値の十分小さい\(h\)に対して常に
        \[ f(a+h) \leq f(a) \]
        が成り立つ事だと言えます。極小値も同様です。この形の論法をよく使います。
        </p>
        </section>

        <section style="font-size:80%">
        <p>
        \(f(a)\)が極大値であるとき，\(f'(a)\)がどうなるか考えます。
        </p>
        <p>
        今言ったように，十分小さい\(h\)に対して常に\(f(a+h)-f(a) \leq 0\)
        が成り立ちます。従って
        \[ \begin{array}{c}
        h<0\text{ならば}\frac{f(a+h)-f(a)}{h}\geq 0\\
         h>0\text{ならば}\frac{f(a+h)-f(a)}{h}\leq 0
        \end{array}\cdots(1) \]
        となります。
        </p>
        <p>
        ところで\(f'(a)\)が存在するならば
        \[ f'(a) = \lim_{h\rightarrow 0}\frac{f(a+h)-f(a)}{h} \]
        だったので，(1)より\(f'(a) = 0\)でなければいけません(もちろん厳密には\(\varepsilon-\delta\)論法で示します)。
        </p>
        <p>
        以上の議論は\(f(a)\)が極小値の時も同様です。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> 極値と導関数の関係 </h4>
          <p>
          \(f(x)\)が\(x=a\)で微分可能のとき，
          \[ f(a)\text{が極値ならば}f'(a) = 0\]
          が成立する。
          </p>
        </div>
        <p>
        直感的には\(y=f(x)\)が滑らかなグラフならば，山の頂点・谷の底で接線が水平になるという事です。
        </p>
        <div align="center"> <img width="400px" src="fig/local-maximum-diff.png"> </div>
        </section>

<!--
        <section style="font-size:70%">
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例</h4>
        データ列\((x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\)に\(y=ax\)というモデルを当てはめる事を考えます。そこで残差平方和
        が最小となる\(a\)を求めましょう。
        </div>
        <p>
        まず
        \[ \frac{\mathrm{d}E}{\mathrm{d}a} = \sum 2x_k(ax_k-y_k) = 2(\sum x_k^2)a - 2\sum x_ky_k \]
        より
        \[ a = \frac{\sum x_ky_k}{\sum x_k^2} \]
        で唯一の極値を取ります。
        </p>
        </section>
-->

        <section>
        <p>
        今の定理は\(f'(a)=0\)の時\(f(a)\)が極大値なのか極小値なのかそもそも極値なのか何も言っていないので注意してください。さらに詳しく調べる為にはより高階の微分係数を考える必要があるので，その為の定理を得た後に再び考察します。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:90%">
          <h4 style="color:pink"> ロルの定理 </h4>
          <p>
          \(f(x)\)が区間\([a,b]\)で連続，区間\((a,b)\)で微分可能で
          \[ f(a)=f(b) = 0\]
          ならばある\(a < c < b\)が存在して
          \[ f'(c) = 0 \]
          を満たす。
          </p>
        </div>
        <div align="center"> <img width="500px" src="fig/rolle-theorem.png"> </div>
        </section>

        <section style="font-size:80%">
        <p>【証明】<br>
        \(f(x)\)が閉区間\([a,b]\)で連続なので，この区間内に必ず最大値と最小値を持つ(<strong>最大値・最小値の定理</strong>)。
        特に\(f(a)=f(b)=0\)なので最大値・最小値の少なくとも一方は開区間\((a,b)\)に存在する。
        </p>
        <p>
        開区間\((a,b)\)内の最大値または最小値は極値でもあるので，これを\(f(c)\)とすると\(f(x)\)は開区間\((a,b)\)で微分可能であるから
        \[ f'(c) = 0 \]
        となる。<span style="float:right">□</span>
        </p>
        <div align="center"> <img width="500px" src="fig/rolle-theorem.png"> </div>
        </section>

        <section>
        <h2> テイラーの定理 </h2>
        <p>
        <strong>テイラーの定理</strong>という，微分法の応用を考える上で非常に重要な定理を紹介します。
        </p>
        <p>
        この定理は様々な場面で利用するのですが，ここでは数値計算を意識して「近似と誤差の評価」という観点から出発したいと思います。
        </p>
        </section>

        <section>
        <h2> 多項式近似 </h2>
        <p>
        計算機は非常に単純な計算しか行えないので，様々な関数\(f(x)\)を和・積のみで計算出来る\(n\)次多項式で
        </p>
        <div class="block" style="border-color:pink;font-size:90%">
        \[ f(x) \approx a_0 + a_1x + a_2x^2 + \cdots + a_nx^n \]
        </div>
        <p>
        の様に近似する一般的な方法があると大変嬉しいです。
        </p>
        </section>

        <section style="font-size:80%">
        <p>
        例えば，\(x = 0\)の近くでは
        \[ \cos x \approx 1 - \frac{x^2}{2} \]
        という二次式での近似が出来ます。こういった式を得る一般的な方法，誤差を評価する方法を考えたいのです。
        </p>
        <div style="float:left;width:400px"> <img width="380px" src="fig/cos-approx.png"> </div>
        <div style="float:right;width:450px;font-size:90%">
<pre><code class="python">>>> from math import cos
>>> for i in range(10):
...     x = i*0.1
...     print "cos({0})={1:.5f}, 1-({0})^2/2={2:.5f}"\
...             .format(x, cos(x), 1-x*x/2)
...
cos(0.0)=1.00000, 1-(0.0)^2/2=1.00000
cos(0.1)=0.99500, 1-(0.1)^2/2=0.99500
cos(0.2)=0.98007, 1-(0.2)^2/2=0.98000
cos(0.3)=0.95534, 1-(0.3)^2/2=0.95500
cos(0.4)=0.92106, 1-(0.4)^2/2=0.92000
cos(0.5)=0.87758, 1-(0.5)^2/2=0.87500
cos(0.6)=0.82534, 1-(0.6)^2/2=0.82000
cos(0.7)=0.76484, 1-(0.7)^2/2=0.75500
cos(0.8)=0.69671, 1-(0.8)^2/2=0.68000
cos(0.9)=0.62161, 1-(0.9)^2/2=0.59500
</code></pre>
        </div>
        </section>

        <section style="font-size:80%">
        <p>
        \(x = 0\)以外を中心とした場合も考えたいので,\(x = a\)を中心として
        \[ \color{yellow}{f(x)\approx \alpha_0 + \alpha_1(x-a)+\alpha_2(x-a)^2+\cdots+\alpha_n(x-a)^n}\cdots(1)\]
        という近似を考えます。\(f(x)\)は\(x=a\)で\(n\)回微分可能であるとします。
        </p>
        <p>
        まず,\(x = a\)で(1)の両辺が一致するように<strong>\( \alpha_0 = f(a) \)</strong>と定めます。
        </p>
        <p>
        次に(1)の両辺を微分すると
        \[ f'(x) \ \text{と}\ \alpha_1 + 2\alpha_2(x-a)+\cdots+n\alpha_n(x-a)^{n-1}\]
        となるので,\(x=a\)での微分係数も一致するように<strong>\( \alpha_1 = f'(a) \)</strong>と定めます。
        </p>
        <p>
        もう一度微分すると
        \[ f''(x)\ \text{と}\ 2\alpha_2 + 6\alpha_3(x-a)+\cdots+n(n-1)\alpha_n(x-a)^{n-2}\]
        となるので,\(x=a\)での二階微分係数も一致するように<strong>\( \alpha_2 = \frac{f''(a)}{2}\)</strong>と定めます。
        </p>
        </section>

        <section style="font-size:90%">
        <p>
        このように\(x = a\)での各微分係数が一致するように係数を決めていった多項式が良い\(n\)次近似多項式となるのではないかと予想できます。
        </p>
        <div class="block" style="border-color:pink;font-size:80%">
        \(x = a\)の周りで
        \[ \begin{aligned}
        f(x) \approx& f(a) + f'(a)(x-a) + \frac{f''(a)}{2}(x-a)^2 + \frac{f'''(a)}{3!}(x-a)^3 + \\
                    &\cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n 
        \end{aligned} \]
        </div>
        <p>
        但し,ここまでは誤差がどの程度出るか判らないので使い物になりません。
        </p>
        </section>

        <section style="font-size:80%">
        <p>
        誤差の項も他の項と同じく「\((x-a)^{n+1}\)の～倍」という形をしていると便利でしょう。そこで
        \[ \begin{aligned}
        f(x) = & f(a) +f'(a)(x-a) + \frac{f''(a)}{2}(x-a)^2 + \\
               &\cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n + \color{yellow}{r\times(x-a)^{n+1}} \cdots (2) 
        \end{aligned} \]
が成立するように\(r\)を定めます。
        </p>
        <p>
        ここで,天下り的ですが\(x\)を固定して
        \[ \begin{aligned}
        F(h) = &f(h)+f'(h)(x-h)+\frac{f''(h)}{2}(x-h)^2 + \\
               &\cdots + \frac{f^{(n)}(h)}{n!}(x-h)^n + r(x-h)^{n+1}-f(x) 
        \end{aligned} \]
        という\(h\)の関数を考えます。複雑な関数に見えますが(2)より
        \[ \color{yellow}{F(a) = F(x) = 0} \]
        が成り立ちます。
        </p>
        </section>
    
        <section>
        <p>
        従ってロルの定理より,\(x \neq a\)かつ「\(F\)が\(a,x\)を含む区間で\(F(h)\)が連続・微分可能\(\cdots (3)\)」ならば,ある\(a < c < x\text{または}x < c < a\)が存在して
        \[ \color{yellow}{F'(c) = 0} \]
        が成立します。
        </p>
        <p>
        \(F(h)\)の定義より,(3)は「\(f\)が\(a,x\)を含む区間で\(n+1\)回微分可能かつ,\(n+1\)階導関数が連続」と言い換えられます。
        </p>
        </section>

        <section style="font-size:80%">
        <p> 最後に </p>
        <div style="font-size:80%">
        \[ \begin{aligned}
        F(h) = &f(h)+f'(h)(x-h)+\frac{f''(h)}{2}(x-h)^2 + \\
               &\cdots + \frac{f^{(n)}(h)}{n!}(x-h)^n + r(x-h)^{n+1}-f(x) 
        \end{aligned} \]
        </div>
        <p>
        より
        </p>
        <div style="font-size:70%">
        \[\begin{aligned}
        F'(h) = &f'(h)+\{f''(h)(x-h)-f'(h)\}+\left\{\frac{f'''(h)}{2}(x-h)^2-f''(h)(x-h)\right\} + \\
               &\cdots + \left\{\frac{f^{(n+1)}(h)}{n!}(x-h)^n - \frac{f^{(n)}(h)}{(n-1)!}(x-h)^{n-1}\right\} - (n+1)r(x-h)^n \\
              = & \frac{f^{(n+1)}(h)}{n!}(x-h)^n-(n+1)r(x-h)^n
        \end{aligned} \]
        </div>
        <p>
        となるので,
        \[ F'(c) = 0\ \Leftrightarrow\ \color{yellow}{r = \frac{f^{(n+1)}(c)}{(n+1)!}} \]
        が得られます。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">テイラーの定理 </h4>
        <p>
        \(a\neq x\)の時,\(f\)が\(a,x\)を含む区間で\(n+1\)回微分可能で\(f^{(n+1)}\)が連続ならば,ある\(c\)が\(a\)と\(x\)の間(\(a < c < x\ \text{または}\ x < c < a\))に存在して
        \[ \begin{aligned}
        f(x) = &f(a)+f'(a)(x-a)+\frac{f''(a)}{2}(x-a)^2+\\
               &\cdots +\frac{f^{(n)}(a)}{n!}(x-a)^n + \frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1} \end{aligned}\]
        が成立する。
        </p>

        <p>
        右辺の剰余項\(\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}\)を\(0\)と置いた物を,\(f(x)\)の\(a\)の周りでの<strong>\(n\)次近似式</strong>という。
        </p>
        </div>
        <p>
        テイラーの定理において\(n=0\)と置いた物は<strong>平均値の定理</strong>と呼ばれます。
        </p>
        </section>

        <section style="font-size:80%">
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例</h4>
        \(\cos x\)の\(x=0\)の周りでの2次近似式と剰余項を求めて下さい。
        </div>
        <p>
        \(f(x)=\cos x\)とおくと\(f'(x)=-\sin x,\ f''(x)=-\cos x\)なので\(f(0)=1,\ f'(0)=0,\ f''(0)=-1\)。また\(f'''(x)=\sin x\)であるからテイラーの定理より
        \[ \begin{aligned}
        \cos x&= 1 + 0\times x + \frac{-1}{2}x^2 + \frac{\sin c}{3!}x^3 \\
              &= 1-\frac{x^2}{2}+\frac{\sin c}{6}x^3
        \end{aligned} \]
        を満たす\(c\)が\(0, x\)の間に存在します。
        </p>
        <p>
        つまり,\(0\)の周りで
        \[ \cos x \approx 1-\frac{x^2}{2},\quad\text{剰余項:}\frac{\sin c}{6}x^3 \ \text{($c$は$0$と$x$の間に存在)} \]
        </p>
        </section>

        <section style="font-size:80%">
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例続き</h4>
        今の二次近似の誤差が\(10^{-4}\)未満に収まる\(x\)の範囲を調べて下さい。
        </div>
        <p>
        \(|\sin c| \leq |c| < |x|\)が成立するので\( \left|\frac{\sin c}{6}x^3\right| < \frac{|x|^4}{6} \)と剰余項を評価できます。よって
        \[ \frac{|x|^4}{6} < 10^{-4}\ \Leftrightarrow\ |x| < 6^{\frac{1}{4}} 10^{-1} = 0.15\cdots \]
        の範囲であれば十分です。
        </p>
<pre style="font-size:70%"><code class="python">>>> from math import cos
>>> for i in range(6):
...     x = i*0.05
...     print "cos({0:.2f})={1:.5f}, 1-({0:.2f})^2/2={2:.5f}, err={3:.5e}"\
...             .format(x, cos(x), 1-x*x/2, cos(x)-(1-x*x/2))
...
cos(0.00)=1.00000, 1-(0.00)^2/2=1.00000, err=0.00000e+00
cos(0.05)=0.99875, 1-(0.05)^2/2=0.99875, err=2.60395e-07
cos(0.10)=0.99500, 1-(0.10)^2/2=0.99500, err=4.16528e-06
cos(0.15)=0.98877, 1-(0.15)^2/2=0.98875, err=2.10779e-05
cos(0.20)=0.98007, 1-(0.20)^2/2=0.98000, err=6.65778e-05
cos(0.25)=0.96891, 1-(0.25)^2/2=0.96875, err=1.62422e-04
</code></pre>
        </section>

        <section style="font-size:80%">
        <p>【練習問題】
        \( \exp x \)の\(x=0\)の周りでの\(n\)次近似式を求めて,\(e=\exp 1\)の近似値を求めて下さい。
        </p>
        <p class="fragment" data-fragment-index="1" style="font-size:70%">【解答】
        \(f(x)=\exp x\)は何度微分しても\(\exp x\)なので\(f^{(k)}(0)=\exp 0= 1\)。従って\(0\)の周りで
        \[ \exp x = 1 + x + \frac{x^2}{2}+\frac{x^3}{3!}+\cdots+\frac{x^n}{n!}+\frac{\exp c}{(n+1)!}x^{n+1} \]
        と展開出来るので
        \[ \color{yellow}{e \approx 1 + 1 + \frac{1}{2} + \frac{1}{3!} + \cdots + \frac{1}{n!}},\quad\text{剰余:}\frac{e^c}{(n+1)!} \quad (0 < c < 1)\]
        となります。
        </p>
<pre class="fragment" data-fragment-index="1" style="font-size:70%"><code class="python" style="max-height:300px">>>> t = 1           # n!の値
>>> e = 1
>>> for k in range(1,10):
...     t *= k      # k! = k*(k-1)!
...     e += 1.0/t
...     print "{0}: {1:.15f}".format(k, e)
...
1: 2.000000000000000
2: 2.500000000000000
3: 2.666666666666667
4: 2.708333333333333
5: 2.716666666666666
6: 2.718055555555555
7: 2.718253968253968
8: 2.718278769841270
9: 2.718281525573192
</code></pre>
        </section>

        <section style="font-size:85%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">テイラー展開 </h4>
        <p>
        \(f(x)\)が無限回微分可能であるとする。ある\(r > 0\)に対して\(-r < x-a < r\)の時
        \[ \lim_{n\rightarrow \infty}\frac{f^{(n)}(c)}{n!}(x-a)^n = 0\quad\text{($c$は$a$と$x$の間)} \qquad\cdots(1)\]
        となるならば,
        \[ f(x) = f(a)+f'(a)(x-a)+\frac{f''(a)}{2}(x-a)^2+\frac{f'''(a)}{3!}(x-a)^3+\cdots \]
        が成立する。これを\(a\)の周りでの<strong>テイラー級数</strong>といい,これを得る事を<strong>テイラー展開</strong>という。
        (1)が成立するような\(r\)の最大値を<strong>収束半径</strong>という。
        </p>
        </div>
        </section>

        <section>
        <p>
        \(0\)の周りでのテイラー級数は特にマクローリン級数と呼ばれます。
        </p>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">主要なマクローリン展開の公式 </h4>
        <p>
        \(x\)は実数であるとします。
        </p>
        <p style="font-size:75%">
        \[ \begin{aligned}
        \exp x &= \sum_{k=0}^{\infty}\frac{x^k}{k!} = 1 + x + \frac{x^2}{2!} +\frac{x^3}{3!}+\cdots  &\text{(収束範囲:全実数)}\\
        \ln (1+x) &= \sum_{k=1}^{\infty}\frac{(-1)^{k+1}}{k}x^k = x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots &\text{(収束範囲:$-1 < x < 1$)}\\
        (1+x)^{\alpha} &= \sum_{k=0}^{\infty}\binom{\alpha}{k}x^k = 1+ \alpha x + \frac{\alpha(\alpha-1)}{2!}x^2 +\cdots &\text{(収束範囲:$-1 < x < 1$)} \\
        \frac{1}{1-x} &= \sum_{k=0}^{\infty}x^k = 1 + x + x^2 + x^3 + \cdots &\text{(収束範囲:$-1 < x < 1$)} \\
        \sin x &= \sum_{k=0}^{\infty}\frac{(-1)^k}{(2k+1)!}x^{2k+1} = x - \frac{x^3}{3!} + \frac{x^5}{5!} -\cdots &\text{(収束範囲:全実数)} \\
        \cos x &= \sum_{k=0}^{\infty}\frac{(-1)^k}{(2k)!}x^{2k} = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots &\text{(収束範囲:全実数)}
        \end{aligned} \]
        </p>
        </div>
        </section>

        <section graphics="sin-taylor">
        <p> \(\sin x\)のテイラー展開の様子 </p>
        <svg></svg>
        </section>

        <section graphics="exp-taylor">
        <p> \(\exp x\)のテイラー展開の様子 </p>
        <svg></svg>
        <svg></svg>
        </section>

        <section graphics="log-taylor">
        <p> \(\ln x\)のテイラー展開の様子(収束範囲の様子をよく観察しましょう) </p>
        <svg></svg>
        </section>

        <section>
        <h2> ランダウの\(\mathcal{O}\)記法 </h2>
        <p>
        \(x\)が\(0\)に十分近いときの誤差は\(|x|^n\)の適当な定数倍で抑えられるということを
        \[ f(x) = g(x) + \mathcal{O}(x^n) \]
        と表します。例えば
        \[ \cos x = 1 - \frac{x^2}{2} + \mathcal{O}(x^4) \]
        などと書きます。
        </p>
        </section>

        <section>
        <h2> 関数の変化と微分係数 </h2>
        <p>
        テイラーの定理を応用する\(f(x)\)の変化の様子と微分係数の関係について様々な事を示す事が出来ます。ここでは<strong>増減</strong>,<strong>凹凸</strong>,<strong>極大・極小の判定</strong>という3つの話題を紹介します。
        </p>
        </section>

        <section style="font-size:90%">
        <h2> 増減 </h2>
        <p>
        \(x=a\)を含む区間で\(f(x)\)が微分可能,\(f'(x)\)が連続であるとします。テイラーの定理より\(x\)が\(a\)に十分近いとき
        \[ f(x) = f(a) + f'(c)(x-a) \]
        と表せます。
        </p>
        <p>
        ここで\(f'(a) > 0\)ならば\(x\)と\(a\)が十分近いとき\(f'(c) > 0\)となるので,
        \[ \begin{aligned}
        x > a\ \text{ならば}\ f(x) > f(a) \\
        x < a\ \text{ならば}\ f(x) < f(a)
        \end{aligned} \]
        となります。つまり\(f'(a) > 0\)ならば\(x=a\)の近辺で\(f(x)\)は単調に増加する事が判ります。\(f'(a) < 0\)の場合も同様です。
        </p>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink"> 増減と微分係数 </h4>
        <p>
        \(x=a\)で\(f(x)\)が微分可能,\(f'(x)\)が連続のとき
        \[ \begin{aligned}
        f'(a) > 0\ \text{ならば}\ f(x)\text{は$x=a$の近辺で単調増加} \\
        f'(a) < 0\ \text{ならば}\ f(x)\text{は$x=a$の近辺で単調減少} 
        \end{aligned} \]
        </p>
        </div>
        <p>
        \(f'(a)\)は接線の傾きなので直感的にも理解出来ると思います。
        </p>
        <div align="center"> <img width="500px" src="fig/increase-diff.png"> </div>
        </section>

        <section style="font-size:90%">
        <h2> 凹凸 </h2>
        <p>
        \(x=a\)を含む区間で\(f(x)\)が2回微分可能,\(f''\)が連続であるとします。テイラーの定理より\(x\)が\(a\)に十分近いとき
        \[ f(x) = f(a) + f'(a)(x-a) + \frac{f''(c)}{2}(x-a)^2 \] 
        と表せます。
        従って,\(f''(a) > 0\)ならば\(x\)と\(a\)が十分に近いとき\(f''(c) > 0\)となるので
        \[ f(x) > f(a) + f'(a)(x-a) \]
        が成立します。
        </p>
        <p>
        これは\(x=a\)の近辺で\(y=f(x)\)のグラフが接線\(y=f(a)+f'(a)(x-a)\)よりも上にある事を意味します。
        </p>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink"> 凹凸と微分係数 </h4>
        <p>
        \(x=a\)で\(f(x)\)が2回微分可能,\(f''(x)\)が連続のとき
        \[ \begin{aligned}
        f''(a) > 0\ \text{ならば}\ y=f(x)\text{は$x=a$の近辺で下に凸} \\
        f''(a) < 0\ \text{ならば}\ y=f(x)\text{は$x=a$の近辺で上に凸} 
        \end{aligned} \]
        </p>
        </div>
        <div align="center"> <img width="700px" src="fig/convex-diff.png"> </div>
        </section>

        <section>
        <h2> 極大・極小 </h2>
        <p>
        \(f(x)\)は\(x=a\)を含む区間で２回微分可能で，\(f(a)\)が極値であるとすると
        \(x\)が\(a\)に十分近い時，ある\(c\)が\(a\)と\(x\)の間に存在して
        \[ \begin{aligned}
                        &f(x) = f(a) + f'(a)(x-a) + \frac{f''(c)}{2}(x-a)^2\\
                        \Leftrightarrow &f(x)-f(a) = \frac{f''(c)}{2}(x-a)^2\qquad(\because f'(a)=0)
        \end{aligned}
        \]
        と表せます。
        </p>
        <p>
        従って\(f''\)が連続で,\(f''(a) < 0\)だとすると\(x\)が\(a\)に十分近い時
        \[ f(x)-f(a) < 0 \ \Leftrightarrow\ f(x) < f(a) \]
        となるので\(f(a)\)が極大値である事が判ります。極小値についても同様です。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">極値の判定 </h4>
        <p>
        \(f(x)\)を\(x=a\)で２回微分可能で,\(f''\)が連続であるとする。この時
        \[ \begin{aligned}
        &f'(a) = 0,\ f''(a) < 0\ \text{ならば}\ f(a)\text{は極大値}\\
        &f'(a) = 0,\ f''(a) > 0\ \text{ならば}\ f(a)\text{は極小値}\\
        \end{aligned} \]
        である。
        </p>
        </div>
        <div align="center"> <img width="700px" src="fig/local-maxmin.png"> </div>
        </section>

        <section>
        <h2> 差分法 </h2>
        <p>
        関数を変化を考える上で微分係数が重要な役割を果たす事が分かったと思います。
        </p>
        <p class="fragment" data-fragment-index="1">
        ところで,多くの場合\(f(x)\)の表式は既知ではありませんので,
        観測などで得られた<strong>離散的な\(x\)における\(f(x)\)の値</strong>から微分係数を近似的に調べる必要があります。
        </p>
        <div class="fragment" data-fragment-index="1" align="center"> <img width="700px" src="fig/discrete-graph.png"> </div>
        </section>

        <section style="font-size:90%">
        <h2> 前進差分・後進差分 </h2>
        <p>
        \(f(x+\Delta x)\)を\(x\)の周りでテイラー展開すると
        \[ f(x+\Delta x) = f(x) + f'(x)\Delta x + \mathcal{O}(\Delta x^2) \]
        となるので
        \[ f'(x) = \frac{f(x+\Delta x)-f(x)}{\Delta x} + \mathcal{O}(\Delta x) \]
        と近似出来ます。これを<strong>前進差分</strong>と言います。
        </p>
        <p>
        同様に\(f(x-\Delta x)\)を\(x\)の周りでテイラー展開すると
        \[ f(x-\Delta x) = f(x) - f'(x)\Delta x + \mathcal{O}(\Delta x^2) \]
        となるので
        \[ f'(x) = \frac{f(x)-f(x-\Delta x)}{\Delta x} + \mathcal{O}(\Delta x) \]
        と近似できます。これを<strong>後進差分</strong>と言います。
        </p>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">前進差分・後進差分 </h4>
        \[ \begin{aligned}
        f'(x) &\approx \frac{f(x+\Delta x)-f(x)}{\Delta x} \\
        f'(x) &\approx \frac{f(x)-f(x-\Delta x)}{\Delta x} \\
        \end{aligned} \]
        どちらも誤差は(\(f(x)\)が十分滑らかならば)\(\mathcal{O}(\Delta x)\)
        </div>
        <div align="center"> <img width="600px" src="fig/difference-method1.png"> </div>
        </section>

        <section style="font-size:90%">
        <h2> 中心差分 </h2>
        <p>
        \(f(x+\Delta x)\)と\(f(x-\Delta x)\)を\(x\)の周りでテイラー展開すると
        \[ \begin{aligned}
        f(x+\Delta x) &= f(x) + f'(x)\Delta x + \frac{f''(x)}{2}\Delta x^2 + \mathcal{O}(\Delta x^3) \\
        f(x-\Delta x) &= f(x) - f'(x)\Delta x + \frac{f''(x)}{2}\Delta x^2 + \mathcal{O}(\Delta x^3)
        \end{aligned} \]
        となるので２式を引けば
        \[ f(x+\Delta x)-f(x-\Delta x) = 2f'(x)\Delta x + \mathcal{O}(\Delta x^3) \]
        すなわち
        \[ f'(x) = \frac{f(x+\Delta x)-f(x-\Delta x)}{2\Delta x} + \mathcal{O}(\Delta x^2) \]
        となります。これを<strong>中心差分</strong>と言います。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">中心差分 </h4>
        \[ f'(x) \approx \frac{f(x+\Delta x)-f(x-\Delta x)}{2\Delta x} \]
        誤差は\(\mathcal{O}(\Delta x^2)\)
        </div>
        <div align="center"> <img width="600px" src="fig/difference-method2.png"> </div>
        </section>

        <section>
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例</h4>
        \(\exp x\)の\(x=0\)での微分係数(真の値は\(1\))を前進差分・後進差分・中心差分で求めて下さい。
        </div>
<pre style="font-size:60%"><code class="python" style="max-height:300px">>>> from math import exp
>>> for e in range(1,6):
...     dx = 10**(-e)
...     print "{0:.0e} {1:.15f} {2:.15f} {3:.15f}"\
...             .format(dx, (exp(0+dx)-exp(0))/dx, (exp(0)-exp(0-dx))/dx, (exp(0+dx)-exp(0-dx))/(2*dx))
...
1e-01 1.051709180756477 0.951625819640405 1.001667500198441
1e-02 1.005016708416795 0.995016625083189 1.000016666749992
1e-03 1.000500166708385 0.999500166624978 1.000000166666681
1e-04 1.000050001667141 0.999950001666638 1.000000001666890
1e-05 1.000005000006965 0.999995000017240 1.000000000012102
</code></pre>
        </section>

        <section style="font-size:70%">
        <h2> 二階差分 </h2>
        <p>
        \(f(x+\Delta x)\)と\(f(x-\Delta x)\)を\(x\)の周りでテイラー展開すると
        \[ \begin{aligned}
        f(x+\Delta x) &= f(x) + f'(x)\Delta x + \frac{f''(x)}{2}\Delta x^2 + \frac{f'''(x)}{6}\Delta x^3 + \mathcal{O}(\Delta x^4) \\
        f(x-\Delta x) &= f(x) - f'(x)\Delta x + \frac{f''(x)}{2}\Delta x^2 - \frac{f'''(x)}{6}\Delta x^3 + \mathcal{O}(\Delta x^4)
        \end{aligned} \]
        となるので２式を足せば
        \[ f(x+\Delta x)+f(x-\Delta x) = 2f(x) + f''(x)\Delta x^2 + \mathcal{O}(\Delta x^4) \]
        すなわち
        \[ f''(x) = \frac{f(x+\Delta x) - 2f(x) + f(x-\Delta x)}{\Delta x^2} + \mathcal{O}(\Delta x^2) \]
        となります。これを<strong>二階差分</strong>と言います。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink">二階差分 </h4>
        \[ f''(x) \approx \frac{f(x+\Delta x) - 2f(x) + f(x-\Delta x)}{\Delta x^2} \]
        誤差は\(\mathcal{O}(\Delta x^2)\)
        </div>
        </section>

        <section>
        <p>
        差分法によって求めた微分係数の近似値を利用して,方程式の解や微分方程式の解を数値的に求める事が出来ます。これは次回やります。
        </p>
        </section>

        <section>
        <h2 class="chapter-title"> 多変数関数の微分法 </h2>
        </section>

        <section style="font-size:90%">
        <h2> 方向微分係数 </h2>
        <p>
        例として二変数関数\(z = f(x,y)\)について考えます。このグラフは何らかの<strong>曲面</strong>となります。
        一変数関数の場合の微分係数は各点の傾きを表していましたが,多変数関数の場合は下図のように<strong>方向によって傾きが変わる</strong>という事を考慮しなければいけません。
        </p>
        <div align="center"> <img width="500px" src="fig/surface.png"> </div>
        </section>

        <section style="font-size:90%">
        <p>
        \(xy\)平面上の点\(\mathbf{x} = (a,b)\)からベクトル\(\mathbf{u}=(\alpha,\beta)\)の方向に適当に進んだ点の座標は
        \[ \mathbf{x} + h\mathbf{u} = (a + h\alpha, b + h\beta) \]
        と表せます。これを用いて
        \[ \frac{\partial f}{\partial \mathbf{u}}(a,b) = \lim_{h\rightarrow 0}\frac{f(a+h\alpha, b+h\beta) - f(a,b)}{h} \]
        と定義される量を\(\mathbf{u}\)に沿った<strong>方向微分係数</strong>と言います。
        </p>
        <div align="center"> <img width="800px" src="fig/directional-derivative.png"> </div>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink"> 方向微分係数 </h4>
        <p>
        \[ \frac{\partial f}{\partial \mathbf{u}}(a,b) = \lim_{h\rightarrow 0}\frac{f(a+h\alpha, b+h\beta) - f(a,b)}{h} \]
        を二変数関数\(f(x,y)\)の点\((a,b)\)におけるベクトル\(\mathbf{u}\)に沿った<strong>方向微分係数</strong>という。\(||\mathbf{u}||=\sqrt{\alpha^2+\beta^2}=1\)のとき,これは\(\mathbf{u}\)の方向の曲面の傾きを表す。
        </p>
        <p>
        一般に,\(n\)変数関数\(f(x_1,\cdots,x_n)\)に対して点\(\mathbf{a} = (a_1,\cdots,a_n)\)におけるベクトル\(\mathbf{u} = (u_1,\cdots,u_n)\)に沿った方向微分係数を
        \[ \begin{aligned}
        \frac{\partial f}{\partial \mathbf{u}}(\mathbf{a}) &= \lim_{h\rightarrow 0}\frac{f(\mathbf{a}+h\mathbf{u})-f(\mathbf{a})}{h}\\
        &=\lim_{h\rightarrow 0}\frac{f(a_1+hu_1,\cdots,a_n+hu_n)-f(a_1,\cdots,a_n)}{h}
        \end{aligned} \]
        によって定義する。
        </p>
        </div>
        </section>

        <section style="font-size:70%">
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例</h4>
        \(f(x,y)=x^2+y^2\)の点\((1,1)\)における各方向の傾きを求めて下さい。
        </div>
        <p style="font-size:65">
        ベクトル\(\mathbf{u}=(\alpha,\beta)\)に沿った方向微分係数は
        \[ \frac{\partial f}{\partial \mathbf{u}}(1,1)=\lim_{h\rightarrow 0}\frac{(1+h\alpha)^2+(1+h\beta)^2 - (1^2+1^2)}{h} = 2\alpha+2\beta \]
        となります。特に\(\mathbf{u}=(\cos\theta,\sin\theta)\)とおけば\(||\mathbf{u}||=1\)なので,その方向の傾きは
        \[ 2\cos\theta + 2\sin\theta = 2\sqrt{2}\sin\left(\theta + \frac{\pi}{4}\right) \]
        となります。これから例えば\(\mathbf{u}=(\pm\frac{1}{\sqrt{2}},\pm\frac{1}{\sqrt{2}})\)の方向の傾きが最も急で,その傾きは\(\pm2\sqrt{2}\)であるといった事が判ります。
        </p>
        <div align="center"> <img width="350px" src="fig/directional-derivative-example.png"> </div>
        </section>

        <section>
        <h2> 偏微分係数 </h2>
        <p>
        二変数関数\(f(x,y)\)の\(y\)を固定して\(x\)のみを変数とみなした時の微分係数を\(x\)に関する<strong>偏微分係数</strong>と言います。
        つまり,点\((a,b)\)における\(x\)に関する偏微分係数は
        \[ \frac{\partial f}{\partial x}(a,b) = \lim_{h\rightarrow 0}\frac{f(a+h, b)-f(a, b)}{h} \]
        と定義されます。これは\(\mathbf{u}=(1,0)\)に沿った方向微分係数だと考える事もできます。
        </p>
        <p>
        \(y\)に関する偏微分係数も同様です。
        </p>
        </section>

        <section style="font-size:90%">
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink"> 偏微分係数・偏導関数 </h4>
        <p>
        \[ \frac{\partial f}{\partial x}(a,b) = \lim_{h\rightarrow 0}\frac{f(a+h, b) - f(a,b)}{h} \]
        を二変数関数\(f(x,y)\)の点\((a,b)\)における\(x\)に関する<strong>偏微分係数</strong>という。
        </p>
        <p>
        一般に,\(n\)変数関数\(f(x_1,\cdots,x_n)\)に対して点\(\mathbf{a} = (a_1,\cdots,a_n)\)における\(x_k\)に関する偏微分係数は
        \[ \frac{\partial f}{\partial x_k}(\mathbf{a})=\lim_{h\rightarrow 0}\frac{f(a_1,\cdots,a_k+h,\cdots,a_n)-f(a_1,\cdots,a_n)}{h}
        \]
        によって定義され,
        \[ \left.\frac{\partial f}{\partial x_k}\right|_{\mathbf{x}=\mathbf{a}},\ \frac{\partial f}{\partial x_k}(\mathbf{a}),\ f_{x_k}(\mathbf{a}) \]
        などと表記する。
        </p>
        <p>
        また,点\(\mathbf{x}=\mathbf{a}\)を動かしたものは関数となり,これを<strong>偏導関数</strong>という。
        </p>
        </div>
        </section>

        <section style="font-size:90%">
        <h2> 高階偏導関数 </h2>
        <p>
        二変数関数\(f(x,y)\)を\(x\)で偏微分して偏導関数
        \[ \frac{\partial f}{\partial x} =f_x\]
        を得た後に,これをさらに\(y\)で偏微分すれば高階の偏導関数
        \[ \frac{\partial}{\partial y}\left(\frac{\partial f}{\partial x}\right) = \frac{\partial^2 f}{\partial y\partial x} = f_{xy}\]
        を得る事が出来ます。このようにして高階の偏導関数を定義する事が出来ます。
        </p>
        </section>

        <section>
        <p>
        ここで,微分する変数の順序が異なる
        \[ \frac{\partial^2 f}{\partial y\partial x} = f_{xy}\ \text{と}\ \frac{\partial^2 f}{\partial x\partial y} = f_{yx}\]
        は同一なのか？という疑問が生じると思います。
        </p>
        <p>
        一般にこれらは異なるのですが,\(f_{xy}\)が連続ならば一致するという事を示す事が出来ます。証明は省略します。
        </p>
        関数\(f\)が<strong>十分滑らかならば偏導関数は微分する変数の順序に依らない</strong>という事を覚えておいて下さい。そして非常に特殊な場合を除き,この仮定は成立しますので,今後は十分滑らかな関数を想定します。
        </p>
        </section>

        <section>
        <h2> 偏微分係数と方向微分係数 </h2>
        <p>
        二変数関数に関して
        \[ \begin{aligned}
        \frac{\partial f}{\partial \mathbf{u}}(a,b) &= \lim_{h\rightarrow 0}\frac{f(a+h\alpha, b+h\beta) - f(a,b)}{h} \\
        &= \tiny{\lim_{h\rightarrow 0}\left\{\frac{f(a+h\alpha, b+h\beta)-f(a, b+h\beta)}{h\alpha}\alpha + \frac{f(a,b+h\beta)-f(a,b)}{h\beta}\beta\right\}}\\ 
        &= f_x(a,b)\alpha + f_y(a,b)\beta 
        \end{aligned} \]
        であるので,偏微分係数があれば方向微分係数を求める事が出来ます。
        </p>
        </section>

        <section>
        <div class="block" style="border-color:pink;font-size:80%">
        <h4 style="color:pink"> 偏微分係数・偏導関数 </h4>
        <p>
        関数\(f(\mathbf{x})=f(x_1,\cdots,x_n)\)の点\(\mathbf{a}=(a_1,\cdots,a_n)\)におけるベクトル\(\mathbf{u}=(u_1,\cdots,u_n)\)の方向の方向微分係数は
        \[ \frac{\partial f}{\partial\mathbf{u}}(\mathbf{a}) = f_{x_1}(\mathbf{a})u_1+\cdots + f_{x_n}(\mathbf{a})u_n \]
        となる。
        </p>
        <p>
        また,\(||\mathbf{u}||=1\)の時の偏微分係数の大きさ
        \[ \left|\frac{\partial f}{\partial\mathbf{u}}(\mathbf{a})\right| \]
        はベクトル\((f_{x_1}(\mathbf{a}),\cdots,f_{x_n}(\mathbf{a}))\)とベクトル\(\mathbf{u}\)が平行のとき最大値となり
        \[ \sqrt{f_{x_1}(\mathbf{a})^2 + \cdots + f_{x_n}(\mathbf{a})^2}\]  
        を取る。
        </p>
        </div>
        <p>
        後半の事実は<strong>コーシー・シュワルツの不等式</strong>により示されます。
        </p>
        </section>

        <section>
        <p> 【練習問題】<br>
        先ほどの\(f(x,y) = x^2 + y^2\)の例を今の定理を利用して解いて下さい。
        </p>
        <p class="fragment">
        各偏導関数は\((f_x, f_y) = (2x, 2y)\)となるので,ベクトル\(\mathbf{u}=(\alpha,\beta)\)に沿った方向微分係数は
        \[ f_x\alpha + f_y\beta = 2\alpha x + 2\beta x \]
        となります。特に,点\((1,1)\)における微分係数は
        \[ 2\alpha + 2\beta \]
        となります。また
        \[ (f_x(1,1), f_y(1,1)) = (2, 2) \]
        なので,これと平行な方向の傾きが最大となりその大きさは
        \[ ||(f_x(1,1), f_y(1,1))|| = \sqrt{2^2+2^2} = 2\sqrt{2} \]
        となります。
        </p>
        </section>

        <section>
        <h2> 勾配 </h2>
        <p>
        ベクトル\((f_{x_1}(\mathbf{a}),\cdots,f_{x_n}(\mathbf{a}))\)は非常に重要なベクトルで\(\mathbf{x}=\mathbf{a}\)における<strong>勾配</strong>と呼ばれ,
        \[ \mathrm{grad} f(\mathbf{a}) = (f_{x_1}(\mathbf{a}),\cdots,f_{x_n}(\mathbf{a})) \]
        と表されます。\(\mathrm{grad} f(\mathbf{a})\)は\(\mathbf{x}=\mathbf{a}\)において最も急な方向(増加率最大な方向)を向いており,その長さが傾きの大きさになっています。
        </p>
        </section>

        <section style="font-size:80%">
        <h2> 応用:勾配法 </h2>
        <p>
        曲面\(y=f(x_1,\cdots,x_n)\)の<strong>最も傾斜の急な方へ下っていく</strong>と\(f\)の最小値に辿りつけそうな気がします。つまり今説明した事実より,適当な定数\(\lambda\)を取って
        \[ \mathbf{x_{k+1}} = \mathbf{x_k} - \lambda \mathrm{grad} f(\mathbf{x_k}) \]
        の様に位置を更新して行けば最小値を得る事が出来そうです。
        </p>
        <p>
        これは<strong>勾配法</strong>(最急降下法)と呼ばれる重要な探索アルゴリズムです。実際には単純なやり方にはいろいろ問題もありますが,基本となるアイデアは理解出来るでしょう。線型代数の回には共役勾配法という同種の解法を紹介します。
        </p>
        <div align="center"> <img width="350px" src="fig/gradient-method.png"> </div>
        </section>

        <section style="font-size:70%">
        <div class="block" style="border-color:lightgreen">
        <h4 style="color:lightgreen">例</h4>
        \(f(x,y)=x^2-4xy+5y^2-2y+2\)の最小値を最急降下法で調べてみます。厳密には\((x,y)=(2,1)\)の時の\(1\)となります。
        </div>
        <p>
        \[ \mathrm{grad}f = (2x-4y, -4x+10y-2) \]
        なので
        \[
        (x_{k+1}, y_{k+1}) = (x_k - \lambda(2x_k-4y_k), y_k-\lambda (-4x_k+10y_k-2))
        \]
        と更新していきます。
        </p>
        <p>
        以下の計算例の様に,工夫しないと収束が遅いです。また\(\lambda\)をちょっと大きくしただけで\(\infty\)に発散してしまいます。よりよい方法は後々やっていきます。
        </p>
<pre style="font-size:60%"><code class="python" style="max-height:300px">>>>> x = 0
>>> y = 0
>>> l = 0.1
>>> for i in range(100):
...     if (i%10 == 0):
...             print "step:{0} (x,y)=({1:.5f},{2:.5f}) f(x,y)={3:.5f}"\
...                     .format(i,x,y,x*x-4*x*y+5*y*y-2*y+2)
...     newx = x - l * (2*x-4*y)
...     newy = y - l * (-4*x+10*y-2)
...     x = newx
...     y = newy
...
step:0 (x,y)=(0.00000,0.00000) f(x,y)=2.00000
step:10 (x,y)=(0.54667,0.39801) f(x,y)=1.42457
step:20 (x,y)=(0.97501,0.57543) f(x,y)=1.21118
step:30 (x,y)=(1.27710,0.70057) f(x,y)=1.10504
step:40 (x,y)=(1.49016,0.78882) f(x,y)=1.05225
step:50 (x,y)=(1.64042,0.85106) f(x,y)=1.02599
step:60 (x,y)=(1.74640,0.89496) f(x,y)=1.01293
step:70 (x,y)=(1.82114,0.92592) f(x,y)=1.00643
step:80 (x,y)=(1.87386,0.94775) f(x,y)=1.00320
step:90 (x,y)=(1.91104,0.96315) f(x,y)=1.00159
</code></pre>
        </section>

        <section style="font-size:90%">
        <h2> 応用:エッジの検出 </h2>
        <p>
        簡単にコードが書ける偏微分の応用例として画像のエッジ検出の話題を紹介します。画像は各点\((x,y)\)に色を表す数値が割り当てられているので二変数関数だと思う事が出来ます。勾配を調べれば色が変化が大きく変化している箇所が判るのでエッジが検出できます。検出精度を上げる為にはさらに高階の微分係数を利用する事になります。
        </p>
        <p>
        このようにデータを解析する際にその特徴がよく分かるように事前に変換を行う事がよくあります。連続的なデータが対象の場合には偏微分法の知識を利用して特徴を調べる事になります。
        </p>
        <div align="center"> <img width="350px" src="fig/edge-detection.png"> </div>
        </section>

        <section style="font-size:80%">
<p>
簡単なコーディングの例です。各ピクセルの値を勾配の大きさに単純に置き換えるだけの例です。
高階微分係数を利用する実装の例も是非調べて見て下さい。
</p>
<pre style="font-size:60%"><code class="python">import math
from PIL import Image
im = Image.open("image.jpg")  # グレイスケールの画像を渡して下さい
new = Image.new(im.mode, im.size, None)
ipix = im.load()
opix = new.load()
im.show()

for x in xrange(1, im.size[0]-1):
    for y in xrange(1, im.size[1]-1):
        dx = (ipix[x+1, y] - ipix[x-1, y])/2    # x方向の偏微分係数(中心差分で近似)
        dy = (ipix[x, y+1] - ipix[x, y-1])/2    # y方向の偏微分係数(中心差分で近似)
        opix[x, y] = math.sqrt(dx**2 + dy**2)   # 勾配の大きさ
new.show()
</code></pre>
      <div align="center"> <img width="300px" src="fig/lego.jpg"> <img width="300px" src="fig/lego-out.jpg"> </div>
        </section>

        <section>
        <h2> 今回はここで終わります。 </h2>
        <p>
        次回は全微分,多変数関数のテイラー展開などのやり残した定理を確認した後,
        線型反復法やニュートン法などの<strong>非線形方程式の数値解法</strong>, 微分方程式の解析的解法とオイラー法やルンゲクッタ法などの<strong>常微分方程式の数値解法</strong>の紹介をします。
        </p>
        </section>
      </div>
    </div>


    <script src="lib/reveal/lib/js/head.min.js"></script>
    <script src="lib/reveal/js/reveal.js"></script>

    <script>
      Reveal.initialize({
        width: 960,
        height: 640,
        controls: true,
        progress: false,
        history: true,
        overview: false,
        touch: true,
        center: false,
        rollingLinks: false,
        transition: "page",
        transitionSpeed: "default",

        // When scale != 1, positions of mouse events will be incorrect.
        minScale: 1.0,
        maxScale: 1.0,

        dependencies: [
					{ src: "lib/reveal/lib/js/classList.js", condition: function() { return !document.body.classList; } },
					{ src: "lib/reveal/plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: "lib/reveal/plugin/zoom-js/zoom.js", async: true, condition: function() { return !!document.body.classList; } },
					{ src: "lib/reveal/plugin/notes/notes.js", async: true, condition: function() { return !!document.body.classList; } }
          ]
      });

      // register event listeners
      require(["MathJax"], function (MathJax) {

        // Delay typesetting of slides
        function typeset (idx) {
          for (var i = idx - 2, n = idx + 2; i <= n; i++) {
            var slide = Reveal.getSlide(i);
            if (!slide) continue;
            if (!slide.typeset) {
              MathJax.Hub.Typeset(slide);
              slide.typeset = true;
            }
          }
        }

        function initializeGraphics (idx) {
          for (var i = idx - 2, n = idx + 2; i <= n; i++) {
            var slide = Reveal.getSlide(i);
            if (!slide) continue;
            var graphics = slide.getAttribute("graphics");
            if (graphics && !slide.initialized) {
              slide.initialized = true;
              (function () {
                var p = slide;
                require([graphics], function(g) {
                  if (g.initialize) g.initialize(p);
                });
              })();
            }
          }
        }

        function start (slide) {
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.start) g.start(slide); });
          }
        }

        function stop (slide) {
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.stop) g.stop(slide); });
          }
        }

        function simpleEvent (type) {
          var event = document.createEvent("HTMLEvents");
          event.initEvent(type, true, true);
          return event;
        }

        Reveal.addEventListener("slidechanged", function (event) {
          typeset(event.indexh);
          initializeGraphics(event.indexh);
          start(event.currentSlide);
          stop(event.previousSlide);
        });

        Reveal.addEventListener("fragmentshown", function (event) {
          var slide = Reveal.getCurrentSlide();
          var graphics = slide.getAttribute("graphics");
          if (graphics) {
            require([graphics], function(g) { if (g.proceed) g.proceed(slide); });
          }
        });

        typeset(Reveal.getIndices().h);
        initializeGraphics(Reveal.getIndices().h);
        start(Reveal.getCurrentSlide());
      });
    </script>
  </body>
</html>
